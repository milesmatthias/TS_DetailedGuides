In this week's episode, we'll be taking a look at how to implement a tab-based application in a single JavaScript context in Titanium Mobile.  Throughout our reference guides and official training course, we generally advocate the use of a single JavaScript context in your Titanium applications.  

However, in our most popular demo application, the Titanium Mobile Kitchen Sink, a tab-based application is developed using multiple contexts by associating each window opened with a URL to a JavaScript file.  While this approach is technically valid, it presents the developer with difficulties around sharing data between windows, confusion around when code for a window has been executed, possible object reference issues which can lead to memory leaks, and reloading of JavaScript code in every window for shared libraries.  

For those reasons, unless you have a specific need for a "clean slate" in every window, using multiple JavaScript contexts cannot be considered a best practice approach to structuring a Titanium Mobile application.

In this example application, we are going to explore how to structure a tab based application in a single JavaScript context. We'll avoid the problems around multiple contexts entirely, while retaining the code organization benefits of having a single JavaScript file associated with a window.

Our demo application its self is not terribly exciting - we've basically refactored the default application generated by Titanium Studio and added a button to each window.  In a tabbed application in Titanium Mobile, each tab has a stack of windows associated with it.  Rather than opening the window directly, you call the open function on a tab, passing a window to it, which pushes a new window onto the stack associated with the tab.  When the window is closed, either programmatically or via the back button, the window is popped from the stack associated with the tab, and you are returned to the previous window for the tab.

This is all easy to do in a single context application, but one thing you'll notice right away is the lack of certain magic variables which are set for you in a multiple context application, such as Ti.UI.currentTabGroup, Ti.UI.currentTab, and Ti.UI.currentWindow.  While these are nice to have, it's actually very easy to mimic these global variables in a single context.  Let's take a look at how that works.

The first order of business in this application template is to monkey-patch the built in implementation of commonJS require on the global object to add in a few extra bits of functionality.  The first feature of this require replacement is that it only loads a module once per execution context, allowing you to require the module in many places in your code, but not have to worry about the JavaScript for the module being evaluated every time it is required.

The second bit of sugar added by this require replacement is that it automatically returns an an instantiate-able object if the module name corresponds to an object on the exports object.  For example, let's say I have a module Foo, which contains an instantiate-able object by the same name.  If I require that module, the variable is automatically set up to be the Foo constructor, without having to use the dot notation at the end of the require statement.  This patch is required because in Titanium, you cannot directly assign an object to the exports object its self.

Moving back to app.js, we will next create an object called globals which will retain references to any objects we intentionally wish to make globally available.  in our case, we want a reference to the application's tab group to be globally available, so we will store a reference to it in this object.

Next, we create a self calling function, which will allow us to avoid polluting the global scope with further variable declarations.  Inside, we will require both the AppTabGroup and AppWindow modules, which we will use to compose our main application interface.

Now we use our AppTabGroup constructor function to create the globally available tab group object.  To our constructor, we pass in JavaScript object literals which will be used to construct tab objects for this tab group.  On each object, we specify a title, an icon, and a window to be displayed inside the tab.  After creating the tab group, we open it to show the UI.

Inside our AppTabGroup module, we will again use the technique of Parasitic Inheritance that we first saw in Episode 3.  The instance of AppTabGroup will in fact be a Ti.UI.TabGroup object, which we will extend with custom properties.

Next, we loop through the tab objects to add them to the tab group.  Note that in JavaScript, we don't need to specify every argument to the function - the function has access to a special array-like object called "arguments" which contains all the arguments passed to the function.  For each argument, we create a tab object based on those parameters.

For the first tab, we create an instance variable on our component called currentTab, which will be globally accessible by the rest of our application.

We add that tab object to the tab group, and our UI is ready to be displayed.

When the currently active tab is changed, we will need to update the currentTab property to indicate which tab has been selected.  To accomplish this, we will use the focus event on the tab group, whose event data will indicate to us which tab has been selected.

By implementing this instance variable on our application's tab group, we have effectively eliminated the need for the Ti.UI.currentTab attribute present in applications using multiple JavaScript execution contexts.

In our AppWindow component, we create a parasitic subclass of Ti.UI.Window, passing in the arguments hash we got as the first argument in the constructor.  To our window object, we add a button which we will press to open up a new window in the tab group.

Inside the button's click event handler function, we access the globally available tabs object, which gives us a reference to the current tab.  Once we have a reference to the current tab, we can push a new window onto the stack of windows associated with the tab, as seen here.

In this example, we have seen how we can implement a single context tab group, using the CommonJS module patterns we have discovered previously.  Thank you very much for watching, and I look forward to meeting many of you personally at our first annual developer conference next week in San Francisco.  Thanks again, and Code strong!



