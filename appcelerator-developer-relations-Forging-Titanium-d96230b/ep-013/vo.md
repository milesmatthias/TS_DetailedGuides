Hey everybody! Thanks for joining us for another episode of "Forging Titanium"! This week we'll be exploring how we can use Android Services & Intents to launch Android notifications to the status bar. This is a great way to let your users know when there's new content or interaction available in your currently running apps. And fortunately for us Titanium developers, this powerful platform-specific functionality is built right into the core Titanium Javascript API.For those of you unfamiliar with Android Notifications, let's take a look at one right now. Here I have my test application, notify, which demonstrates a few ways you can utilize Android notifications in your apps. The simplest case is an immediate notification based on user interaction. So if we click the "Immediate Notification" button, you'll see that a notification immediately pops up in the status bar, showing us our app's icon and a brief message to go along with it.To show the notification in action, let's leave our app. Now, if we open the status bar's sliding drawer, we see the details of our notification. This includes the app's icon, a title, a brief message, and the time that the notification was launched. If we then click on the notification, the sliding drawer closes and we are immediately taken back to our app. So as you can see, this is an extremely useful feature that can be utilized to send your users back to your app whenever you'd like. Let's expand on that "whenever you'd like" statement. Let's say you wanted a notification to be launched after a certain amount of time, or at a specific interval. For this we can use pending notifications. To demonstrate, we'll click on the "Pending Notification" button. This will launch a pending notification, based on a pending intent, in 4 seconds. So if we wait... we'll see our notification pops up just like it did before, but this time after the specified interval. In this case we set our pending notification to only be launched once, but you can also set reoccurring intervals. This can be done with a minor modification in the code that we'll discuss in a little bit. Once again we can open up the status bar, click on our notification, and go back to the app.Notifications based on button clicks are an easy way to demonstrate how they work, but they aren't the most practical use case. We typically want to launch notifications when our users aren't already interacting with our app. A common case for this would be sending updates from background services. Let's demonstrate how we can do that using Titanium's Geolocation module to receive location events while our app is in the background. Before moving on, though, it's worth noting that your android emulator needs to be configured to support GPS services before you can test this functionality yourself. Also, the emulator has no built-in facility for generating location events, so you'll need to do this via the Dalvik Debug Monitor. Both the configuration of your emulator for location services and using DDMS to send location events are covered in detail in the wiki documentation guide for location services.Let's go back to our app and send it to the background by clicking the home button on the emulator. You'll notice that there is currently no GPS data present in the app yet. Now, with our app in the background, let's open DDMS, attach it to our emulator, click on the "Emulator Control" tab, then scroll down to location controls. Here you see how we can send longitude and latitude coordinates to be processed as location events in our Android emulator. Let's click "send" and see what happens... As soon as our app, running in the background, receives the location event, it launches a notification to let us know that is was received. In addition, our app's UI was also updated with the latitude and longitude that was contained in the event. While I used the `Titanium.Geolocation` module as my background service, you can potentially use any background service to launch these types of notifications. You could have native Android notifications letting your users know when an RSS is updated, when they have received a message, or any other noteworthy event you'd like to track.So now that we've seen how notifications behave in the Android OS, let's take a look at the Titanium code necessary to create them.At the very top of the app.js for the notify app, we have the function `createNotificationViaService`, which does exactly what its name implies for all of our events. In it, we create a service intent based off of a Javascript service we've already written, called `ExampleService.js`. This service is the core of our notification functionality, and we'll get to the code for it shortly.After we've created our service intent, we add any additional information we'd like to use via Intent Extras, like a message or time interval, and then launch the service. If you didn't specify an interval, the notification will be launched immediately. If you did, the notification will be launched after the specified amount of milliseconds, regardless of whether or not your app is still in the foreground.The rest of the code in the app.js is primarily UI construction and setting up events that will eventually call the `createNotificationViaService` function. We use simple click handlers for the buttons... we add the `orientationchange` handler to the `Ti.Gesture` module in order to alert on orientation changes... and as we just demonstrated, we set up a location event listener on the `Ti.Gelocation` module. One quick note is that in this simple app the location event listener will run constantly, whether in the foreground or background. This can be a real drain on a device's battery and should only be done when you absolutely need constant access to GPS information. once again, the location services guide in the wiki documentation covers how to manage location events in a power efficient manner. Now let's look inside the workhorse, `ExampleService.js`. This is where all the heavy lifting is done in terms of leveraging Android's native notification and service functionality. Before we walk through the code, I just wanted to mention that there are a lot of advanced Android topics covered here and it may seem a bit overwhelming for developers not familiar with the underlying Android system. We have a number of references you can use to expand your knowledge on these subjects, including the `Ti.Android` API documentation, the various platform specific wiki guides related to Android, as well as blog posts on the developer blog regarding the usage of Android Intents. If you really wanna dig in, you should also check out the official Android documentation from Google regarding Services, Intents, and Notifications.OK, you've been warned, so here we go. The first thing we do is grab the service and service intent that were created when we called `createServiceIntent` in our app.js. From the service intent we gather the message and interval from its extra values. In the case of an interval, we don't want to run the service immediately, we want to run it after the amount of milliseconds specified by the interval. To make sure interval-based notifications are launched only after this time, we use the `Ti.App.Properties` module to track whether or not the service has run yet. Once we are ready to execute the service, we create the Android Intent that will launch our original app from its app.js file, as indicated by the Intent action `ACTION_MAIN`. You can also specify flags from the `Ti.Android` module to modify the behavior of your intent. In this case we allow the intent to reset the task if necessary, as well as telling it to route the intent through any existing instance of our app before attempting to open a new instance.In order to reference the activity, or app, to be opened via the `url` property, we need to create an instance of this activity in the AndroidManifest.xml file. Fortunately, we can do so via our project's tiapp.xml file. Looking at the android element of our tiapp.xml shows the necessary modifications for adding a new activity and service to your Titanium app. You'll notice that the new activity uses the existing app.js as its source, just as our newly created Android Intent does. This new activity also shares the same action and category elements as does a typical native Android activity... you can also see the simple syntax for adding `ExampleService.js` as an Android Service. It is critical to remember, though, that `url` property assigned in the tiapp.xml _**MUST**_ be the same as the `url` property you assign to your intents and services in your Titanium Javascript code. We next build a pending intent, based on the current activity and the intent we just created. The pending intent is what allows us to launch the app from the notification itself.And speaking of the notification, we finally create it with the `createNotification` function. In it we assign the pending intent we want it to use to launch our app, the title, content & ticker text, timestamp, and the  icon we'll use to represent it in the status bar's sliding drawer list. You'll notice that here we leverage Android's access to its own app icon via the `Ti.App.Android.R.drawable.appicon` property. While this is a very common way to show your notifications, you are free to use any image you'd like here.One last property set for our notification is its flags. From this bitwise list we can add features to our notifications like vibration, using LED lights, or even specify whether we want the notification to be a one-timer or persistent one. This gives us a lot of flexibility with how we can tell our users about updates, both informational and critical.Finally we just need to launch our notification with the `NotificationManager`'s `notify` function. The function takes 2 parameters: the first is a unique integer id you assign to the notification. This id affords you the opportunity to cancel the notification if you deem it necessary at some point. The second parameter is the notification we've just  created. With these 2 parameters Android is now ready to launch your native notification.So as I mentioned earlier, we covered a lot of advanced Android topics in this episode. Titanium's underlying Android components like Intents, Services, and Notifications allow us to leverage powerful native functionality to deliver apps that more readily engage our users. And in the mobile space where app usage sessions are measured in seconds, that constant engagement is what can make or break the success of your apps.Thanks for checking out this episode of "Forging Titanium". See ya next time! 