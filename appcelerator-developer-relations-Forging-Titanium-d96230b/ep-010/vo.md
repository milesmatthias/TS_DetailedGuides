Hey everybody! Thanks for watching this screencast. In this week's episode of Forging Titanium we'll be seeing how we can use CommonJS patterns to develop a simplified interface for creating cross platform mobile forms. As we well know, forms are the universal method for user data entry in web applications, and now we want to do the same using native mobile components. While this may seem a very simple task on the surface, the devil is in the details, especially when it comes to user experience. Let's take a look at the simple form app I've created to show how with careful abstraction, we can create a highly usable experience with a clear separation between the business logic and the UI code.As stated earlier, this is a cross platform solution so you'll notice that the iphone and android forms look very similar, running off identical code bases.  Scrolling through each we see a pretty standard user entry form. The fields presented here account for most of the different values you would typically query from a user. The more important thing is that they represent a wide array of different native UI components.Let's step through each field to see how careful attention to data entry details can make for a higher quality user experience. We start with standard Name field. This is simply a TextField with the default settings, sort of the control component for this experiment. The Address and City fields use this same basic component.The Email field, another TextField, uses the keyboardType property of Ti.UI.KEYBOARD_EMAIL. This signifies that the app should load the email-specific keyboard when this textField has focus, making it easier for our users to enter their email addresses. Let's get rid of the keyboard to show another key feature to keep in mind when building mobile forms. Let's click on City and see what happens... Notice that on both Android and iOS  the app moved our focused TextField to a position above the keyboard. While Android will typically do this automatically, both Titanium and native iOS developers have battled the keyboard covering the focused component for a while now. We counter this by simply making sure our form is in a ScrollView component, rather than a normal View. Notice also that this allows us to navigate through the rest of the form even when the soft keyboard is open...Moving on in the app we have our first non-textfield component in the State field. In order to leverage native behavior, we present the state listing differently on each platform. With Android, we use the standard Picker to display a pop up list of available states when the picker is clicked, like this... With iphone however users are accustomed to a different type of interaction. To account for this, we use an iphone style Picker. When we click the State placeholder textfield, we automatically open one of these pickers for our users, like so... The picker is opened in a semi-modal fashion, giving an intuitive interface for making a selection.After State, our app has 3 more fields that make use of the textfield representation properties. Zip Code and Phone both use the keyboardType property to show a number pad when focused, and the password field uses the passwordMask property set to true to mask our input as we type...Our last field is the birthday date picker. Once again, these have different native representations on each platform, but we will soon see in the code that they can be handled very similarly. With Android, we can make our selections inline using either the incrementors and decrementors, or typing values directly into the date picker fields...With iphone we once again leverage the semi-modal picker to show the native iphone date picker. Just as with the states, the user can spin through the values, this time to set their birthday, then click "done" to set the value for the form.Finally we have the submit button. This, as you might imagine, is what will launch our business logic that handles the form data. In the case of this app, it simply pops up an alert dialog with the values of each of our form fields, indexed by a given id...I know what you're thinking... Isn't configuring all those UI components going to be a lot harder than doing so in HTML?  Aren't I going to have to go through and get those values from all these UI components individually? The short answer, through the power of modular Javascript, is no. Let's take a look at the main app.js to see just how simple it is to define this form...If you subtract the definition of the states array, I've used only about 25 lines of code to define that whole custom form. This leaves my app.js clean and uncrowded for when my business logic grows beyond the scope of the cursory alert dialog. As you can see, the definition of my form fields has been reduced to simply a title, type, and id for each field. The picker type also has the additional data field to populate the picker. If we look again at the output of clicking submit... you'll notice that all the values correspond to the ids specified in this definition, making them very simple to work with.Just for fun, let's change the style of our form from STYLE_LABEL to STYLE_HINT and see what our new form looks like... With that quick change we adjusted the whole form to use hint style labeling, rather than an explicit label above each field.So how did I make form creation so simple? By carefully abstracting the underlying functionality of the form and exposing only the critical functions and properties necessary to process it via CommonJS. Let's take a look at the forms.js module to see how this was done.The first thing you'll notice are the constant values we used to define the style of our form, as well as the type of each form field. Exposing constants in this manner makes it much clearer how to use certain features of your module. Moving along we see that each textfield type is mapped to a corresponding keyboard type. This is a lot easier to manage and read than conditional statements littered throughout your module.handleStyle is the function that applies the specified styles to our form fields. While only STYLE_HINT and STYLE_LABEL are defined, you could easily extend the styling capabilities of this module by adding additional conditions to this function.setupPickerTextField is how we create our semi modal picker for iphone. Here we style and prepare the placeholder textfield, as well as the picker itself. Once again we take advantage of a commonJS module to encapsulate the creation and functionality of the semi modal picker. To see how this UI module was created, be sure to check out the Github repository for this episode. Its link is included in the accompanying blog post.The addField function is where each form field is created based on the field definitions given in app.js. As we look through here, we can see the individual configurations necessary for each specific component, as well as the use of the previously defined functions for common behaviors.You'll probably notice that the SUBMIT type is a little different than the other form field components. The submit button is NOT added to the list of values for the form. It instead has the sole purpose of firing an event when it is clicked that returns the values of each field in the form. We can see this in the app.js...The submit button was defined with the ID of 'registerUser', which in turn is the name of the event that it fires when clicked. This allows us to listen for the 'registerUser' event on the form itself, never having to worry ourselves about the underlying UI. Here we could do anything we want with the data, including validation, normalization, and applying business logic.In this episode we learned how to create a cross platform, reusable form module that doesn't require you to define a single form field UI component yourself. You are left to worry only about your business logic, which is the whole point of forms in the first place. This is just another example of how the power of commonJS modules can deliver clean, usable simplicity to your code.Thanks for watching. See ya next time.