Hey everybody! Thanks for checking out this screencast. In this week's episode of Forging Titanium we'll be integrating the Date.js library into a Titanium app. If you can't guess by the name, Date.js's primary objective is to add loads of convenience and functionality to the native Javascript Date object. By taking a look at the Date.js website, we can quickly see that its syntax is meant to be very clear and expressive. This is achieved primarily through Date.js's improved date string parser. As Javascript developers well know, formatting dates to be used by the Date object can be a troublesome tasks at times, especially when considering the multitude of sources and formats with which a date can be received.Here in the getting started guide we see a good example of the more robust parser in action. The Date.parse function, added by the Date.js library, allows the Javascript Date object to handle far more date string values and formats than it ever could before. You'll note in this guide... and in the expansive API documentation... that Date.js also offers many additional functions for modification, formatting, and comparison.While it's _really_ fun to sit and read documentation about date formatting all day long, why don't we move on to applying the features of this library to a Titanium app. To do this, we'll obviously first have to download the library itself.On the download page, we have 2 choices. For the sake of this screencast, we'll just be downloading the date.js file and including it in our Titanium test project. This gives us everything we need to handle dates in the standard English US format. If we wanted to support one or more of the 150 culture-specific versions Date.js has made available, we would download the zip file on this page, which includes Javascript files for each. With the date.js file downloaded, let's take a look at the cross platform Titanium app I've already created with it.As you can see, it's a pretty simple app that provides you a TextField with which you can test the parsing functionality of Date.js. We can test it with values like days of the week... date modifiers... or just standard date formatting...In addition to being able to type in your date value, you can also make use of the platform specific picker controls to choose one of the suggested test values. As is evident, _many_ date formats are supported, and can easily be cycled through using the Picker. Be sure to check out the Date.js documentation for a full listing of all the formats it can handle.Now that we've seen what Date.js can do for our mobile apps, let's take a look at the code to see just how easy it is to incorporate. The first thing we'll note is the manner in which we include the date.js file. As we always should whenever feasible, we include Date.js as a CommonJS module. Now I know what you may be thinking. Date.js only extends the native Date and Number objects, it doesn't export anything. What's the advantage in including as a module?  Well, even though the Date.js library doesn't export any functionality from the module, it could still potentially pollute the global scope with variables and functions. CommonJS enables us to include all of Date.js's functionality in our native Javascript objects, while still safely encapsulating the library's code. Even though it doesn't export a single object, the CommonJS require used here is a fine example of integrating existing Javascript libraries into modular code.Following the require, we have the list of test date values that populated the native Android and iOS Pickers in the app. While not comprehensive, they give a good sampling of what Date.js can successfully parse.As we scroll through the UI code, we'll stop at the creation of our picker. Although the physical appearance of the picker on each platform is very different, it still comes from the very same code base. Only minor platform-specific tweaks are made to ensure the user's expected experience is delivered.Moving on we find the core of the app's functionality in the main TextField's `change` event handler. As is evident here, it doesn't take much code to leverage Date.js's powerful parsing functionality. We simply validate that we have a string value to parse... attempt to parse it with the Date.parse function... and then display it in our app if the date is successfully parsed.  As you might imagine, you can change the returned date format to anything you want in the toString() function. The specifiers you can use in the formatting string are covered exhaustively in the "format specifiers" section of the Date.js wiki.With our user input handled via the Date.js parse function, we need only assemble our view hierarchy and open our app's main window. One final step, just for the sake of initially presenting the user with today's date, is to manually fire the main TextField's 'change' event. This will cause the default string value of 'today' to be evaluated by the parser, then inserted as the text for the date label.In this episode of Forging Titanium we took the simple, yet powerful Date.js library and used it to add functionality and elegance to our project. With just a few lines of code, we were able to parse and display numerous date formats and modifiers. Additionally, through the use of CommonJS, we did so in a modular fashion.While the parse function is the core of Date.js, there is much, much more to this library. I highly encourage you to go out to the main Date.js website and check out the getting started guides and the API documentation for yourself. You'll find that the common, and often cumbersome, task of date handling can be made much more palatable with the help of this library. All that time you _won't_ be parsing dates can then be spent on adding far more interesting features and components to your Titanium apps.Thanks again for watching this episode of Forging Titanium. See ya next time. 