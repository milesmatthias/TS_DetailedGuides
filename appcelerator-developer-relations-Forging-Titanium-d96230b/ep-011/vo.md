Hey everybody! Thanks for checking out this screencast. In this week's episode of Forging Titanium we'll be looking at how we can use the Javascript library underscore.js in our Titanium apps.In its own words, Underscore is a utility-belt library for JavaScript that provides a lot of the functional programming support that you would expect in Prototype.js, but without extending any of the built-in JavaScript objects. If that doesn't give you a clear enough picture of what Underscore can do, just think of it as jQuery without the DOM. It includes functions for templating, type checking, aggregation, and most notably manipulation of arrays, objects and functions.So obviously the first thing we need to do is go download underscore.js. Enter the URL <https://github.com/documentcloud/underscore/> into your web browser... then click on the underscore.js file. Now download the file to your computer using the "raw" link. Typically we'd just download the packaged version available on the main underscore.js website, but at the time of this episode, we need the absolute latest source version. That's because yesterday we submitted a patch to the underscore project so that it would support being loaded as a CommonJS module in Titanium. Big thanks goes out to Jeremy Ashkenas for the quick turn around on merging this feature, and it should be present in the next official release.Now that we know where to get underscore, let's take a look at how we can use it. In the following sample app, we'll explore a very common task that can be greatly simplified with some clever underscore usage. While this will be far from a comprehensive account of what underscore does, it'll give you a good idea of the types of things it can do for you. I highly suggest checking out the underscore documentation for yourself to see the full list of what it offers.What we'll do is represent a raw JSON array of unordered, unformatted objects as a Titanium TableView. Before doing so, though, we'll make heavy use of underscore to mold the data into a form a bit more visually pleasing. I statically defined the JSON array in this example so it's readily apparent what's going on, but you can most certainly use these methods on local and remote data alike. The very first thing you'll notice is the way we require() the underscore library as a module. Rather than export each of its 60+ functions individually, it exports them all at once, bound to the underscore character. For this reason, we reference the underscore character directly when creating an alias in our code for the module. Now that we have the power of the underscore library loaded into our app's underscore character, let's take a look at the JSON data we're dealing with. As you can see, it's a poorly organized list of different types of alcohol, each with an id number, an availability indicator, and a quantity. Notice that there's duplicated records, unformatted values, and no discernible order. Next we see the definition of 2 object literals that contain Titanium UI formatting properties. The first object contains the properties that will used by all rows in our TableView. The second is the label properties used by the header and footer of our TableView. By defining these here and applying them later with underscore we create a clean separation between our UI code and app logic. This will make the code for creating our TableView much easier to read and maintain. It also encourages less duplication of shared configurations, as we'll see later when defining our header and footer.Now we get a look at what underscore is capable of. Using this function "chain" we will remove all duplicate and "unavailable" records, properly capitalize each object's value, and sort the objects by this value. There's a lot going on here, so let's break it down function by function.The very first thing we do is wrap our JSON data in an underscore object, highlighted here. Those of you who have used jQuery will find this very familiar. By putting our data in an underscore wrapper, we can call its functions in an object oriented manner. More importantly, this affords us the opportunity to create a chain of functions that can perform a sequence of modifications to our JSON data.To initiate that chain of functions, we must first call the aptly named "chain" function. This tells underscore to return the modified wrapped object after each chained function. This allows us to continue calling underscore functions in succession. You can get access to the raw object at any time in the chain by calling the value() function.After the chain has been initiated, our first modification is to eliminate all duplicate id records with the uniq() function. The first parameter is a boolean value that indicates whether or not the list has already been sorted. As it has not, we put false here. The second parameter is one you will find in many underscore functions. It is an "iterator" function, or the function that returns the data to be operated on for each item in your list. In this case, for each object in our JSON array we will return its id number as the value for the uniq() function to evaluate.  The end result is an underscore wrapped array of JSON objects with all duplicate ids removed.Now that duplicates are gone, let's also get rid of any objects whose "available" property is set to false. To do this, we'll make use of the select() function. Like uniq(), it takes an iterator function as a parameter. Basically, if the iterator function returns true, the current object is kept in the wrapped data array. If it is false, it's removed. With duplicates and unavailable objects removed, let's turn our attention to formatting the values a bit. You'll notice in the JSON data that the capitalization of the value property is all over the place. To remedy this, we'll make use of the map() function on each object. map() let's us perform any operation we want on each object in the wrapped data array. When we're finished we simply return the new or modified object from the iterator function and it is then entered back into the array. In this case, we'll be using map() to properly capitalize the value property of our objects. map() is an extremely powerful function and this is just one of the infinite ways it can be used to normalize an array of data.The final operation we'll perform on the wrapped data array is sorting it by the value property. Once again, all we have to do is give the sortBy() function an iterator function that returns the value on which we would like to sort. In this case, we return the value property of each object and sortBy() takes care of the rest. To finish the chain of functions we simply call value(), and the underlying data array is returned, complete with all of our previous modifications.After our data has been formatted and ordered to our liking, we'd like to get a total of all the quantity fields in the array. To do so, we use the underscore function reduce(). reduce() is an interesting function that iterates through each object in a list to produce a single value. Here we are simply taking a summation of all the quantity fields, as we can see defined here in the iterator function.Now it's time to create the rows for the TableView we plan to display. To do so we iterate through each object in the data array using underscore's each() function. For each object, we first create a basic table row using the Ti.UI.createTableViewRow() function. To specify a title, though, we use underscore's templating ability via the template() function. This allows us to specify a template and then apply a named object to it to create complex text. This is obviously a simple example that could just as easily be done with string concatenation, but there are many cases though where this will come in handy, like with modifying HTML or trying to dynamically display local text data.With our rows created, we need now only create our TableView. In typical fashion we assign our rows to the TableView via the data property, but we have 2 more properties to set: the headerView and footerView. Since both will share the same UI formatting properties, we use underscore's extend() function when creating them. extend() takes 2 parameters: the object to be extended and the object with which we will extend it. After execution the first object will contain all the properties of the second object. In this case, the Ti.UI.Label objects created for the header and footer views will be extended with the properties in the `labelProperties` object.With all of our code complete, we can now build and run our app.And there it is. Concise, cross platform Javascript code that has created properly formatted, sorted, and visually displayed data. And this is just one use case for underscore. It can literally be inserted into any of your Titanium apps to add power, functionality, and clarity to your code.I hope you enjoyed this short demo of using underscore.js in your Titanium apps. As Titanium developers, we are constantly looking for ways to not only increase our ability as mobile developers, but as Javascript developers as well. Wrapping your head around utility libraries like underscore and using them in your own code is one important step in that direction. Thanks for watching this episode of Forging Titanium. See ya next time. 